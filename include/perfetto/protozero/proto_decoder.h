/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_PROTO_DECODER_H_
#define INCLUDE_PERFETTO_PROTOZERO_PROTO_DECODER_H_

#include <stdint.h>
#include <array>
#include <memory>
#include <vector>

#include "perfetto/base/logging.h"
#include "perfetto/base/string_view.h"
#include "perfetto/protozero/field.h"
#include "perfetto/protozero/proto_utils.h"

namespace protozero {

// A generic protobuf decoder. Doesn't require any knowledge about the proto
// schema. It tokenizes fields, retrieves their ID and type and exposes
// accessors to retrieve its values.
// It does NOT recurse in nested submessage, it returns their boundaries.
// This class is designed to be used in perf-sensitive contexts. It does not
// allocate and does not perform any proto semantic checks. It it safe w.r.t.
// out-of-bounds memory accesses though.
class ProtoDecoder {
 public:
  static constexpr uint32_t kMaxFieldId = 999;

  // Creates a ProtoDecoder using the given |buffer| with size |length| bytes.
  inline ProtoDecoder(const uint8_t* buffer, uint64_t length)
      : begin_(buffer), end_(buffer + length), read_ptr_(buffer) {}

  // Reads the next field from the buffer. If the full field cannot be read,
  // the returned Field will be invalid (field.valid() == false).
  Field ReadField();

  // Finds a field with the given id. Doesn't affect the read cursor.
  Field FindField(uint32_t field_id);

  // Resets the current position to the start of the buffer.
  inline void Reset() { read_ptr_ = begin_; }

  // Resets to the given position (must be within the buffer).
  inline void Reset(const uint8_t* pos) {
    PERFETTO_DCHECK(pos >= begin_ && pos < end_);
    read_ptr_ = pos;
  }

  // Returns the position of read cursor, relative to the start of the buffer.
  inline uint64_t read_offset() const {
    return static_cast<uint64_t>(read_ptr_ - begin_);
  }

  inline size_t bytes_left() const {
    PERFETTO_DCHECK(read_ptr_ <= end_);
    return static_cast<uint64_t>(end_ - read_ptr_);
  }

 protected:
  const uint8_t* const begin_;
  const uint8_t* const end_;
  const uint8_t* read_ptr_ = nullptr;
};

// Similar to the basic ProtoDecoder. The main difference is that this decoder
// loads all fields upfront (still without recursing in nested messages).
// It is used as a base class for typed decoders generated by the pbzero plugin.
class ProtoDecoderBase : public ProtoDecoder {
 public:
  using FieldArray = std::array<Field, 1000>;

  class RepeatedFieldIterator {
   public:
    RepeatedFieldIterator(uint32_t field_id,
                          FieldArray::const_iterator begin,
                          FieldArray::const_iterator end)
        : field_id_(field_id), iter_(begin), end_(end) {
      FindNextMatchingId();
    }

    inline const Field* operator->() const { return &*iter_; }
    inline const Field& operator*() const { return *iter_; }
    inline explicit operator bool() const { return iter_ != end_; }

    RepeatedFieldIterator& operator++() {
      ++iter_;
      FindNextMatchingId();
      return *this;
    }

   private:
    inline void FindNextMatchingId() {
      for (; iter_ != end_; ++iter_) {
        if (iter_->id() == field_id_)
          break;
      }
    }

    uint32_t field_id_;
    FieldArray::const_iterator iter_;
    FieldArray::const_iterator end_;
  };

  // If the field |id| is known at compile time, prefer the templated
  // specialization Get<kFieldNumber>().
  inline const Field& GetSingle(uint32_t id) { return *GetFieldInternal(id); }

  inline RepeatedFieldIterator GetRepeated(uint32_t field_id) const {
    return RepeatedFieldIterator(field_id, &fields_[0], &fields_[fields_size_]);
  }

  void ParseAllFields();

 protected:
  ProtoDecoderBase(uint32_t max_field_id, const uint8_t* buffer, size_t length)
      : ProtoDecoder(buffer, length),
        max_field_id_(max_field_id),
        fields_size_(max_field_id + 1) {
    // The reason why Field needs to be trivially de/constructible is the
    // std::array member. If Field is not trivial, then the ctor will invoke the
    // initializer on all O(1000) entries. We need it only on the first
    // |max_field_id|, the other uninitialized ones are gated by |fields_size_|.
    static_assert(
        std::is_trivially_constructible<Field>::value &&
            std::is_trivially_destructible<Field>::value,
        "Field must be a trivial aggregate type for performance reasons");
    memset(&fields_[0], 0, sizeof(Field) * fields_size_);
  }

  inline Field* GetFieldInternal(uint32_t id) {
    return id <= max_field_id_ ? &fields_[id] : &fields_[0];
  }

  uint32_t max_field_id_;
  size_t fields_size_;
  FieldArray fields_;
};

template <int MAX_FIELD_ID>
class ProtoDecoder2 : public ProtoDecoderBase {
 public:
  ProtoDecoder2(const uint8_t* buffer, uint64_t length)
      : ProtoDecoderBase(MAX_FIELD_ID, buffer, length) {
    static_assert(MAX_FIELD_ID < std::tuple_size<FieldArray>::value,
                  "The highest proto field id for this message is too high");
    ProtoDecoderBase::ParseAllFields();
  }

  template <uint32_t FIELD_ID>
  inline const Field& Get() const {
    static_assert(FIELD_ID <= MAX_FIELD_ID,
                  "Trying to read a field > MAX_FIELD_ID");
    return fields_[FIELD_ID];
  }
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_PROTO_DECODER_H_
